#!/usr/bin/python3
"""
Name: Server.py
Authors: Roman Kapitoulski, Eric Russon, Maryam Bunama
Version: 2.2
Date: Aug 4, 2023
Description: This script takes the JSON file generated by SysAdminTask.py and sends it to the Server.py software on
the server machine. It performs acknowledgments and error-checking throughout the process. This script uses crontab to run on reboot with
a 20 second delay after SysAdminTask.py.
"""

import socket, hashlib, time, tqdm, os

server_ip = '127.0.0.1' # Change this to the server's IP address.
server_port = 5000 # The port the script will communicate over
buffer_size = 1024 # The size of the packet
EOF = ':EOF:' # The "end of file" character
sep = '}}' # The data separator

def splitFile(fileName):
    # Split filename for relevant information
    fileType, fileDate, fileEnd = fileName.split("_")
    year, month, day = fileDate.split("-")
    fileTime, fileType = fileEnd.split(".")
    hour, minutes, seconds = fileTime.split(":")
    # Append the information to a datetime list
    dateTime = []
    dateTime.append(int(year))
    dateTime.append(int(month))
    dateTime.append(int(day))
    dateTime.append(int(hour))
    dateTime.append(int(minutes))
    dateTime.append(int(seconds))
    return dateTime

def chooseNewestFile(folder):
    # Get list of filenames using os.listdir()
    fileList = os.listdir(folder)
    
    ### Find the latest file
    # Assign the first file as the newest
    newestFile = fileList[0]
    newestFileDateTime = splitFile(newestFile)

    # Loop through fileList
    for fileName in fileList:
        fileDateTime = splitFile(fileName)
        
        # Compare current file to newest file step by step
        is_newer = False
        for i in range(len(fileDateTime)):
            if fileDateTime[i] > newestFileDateTime[i]:
                is_newer = True
                break
            elif fileDateTime[i] < newestFileDateTime[i]:
                break
        
        if is_newer:
            newestFile = fileName
            newestFileDateTime = fileDateTime  # Update the newestFileDateTime for further comparisons
    
    return newestFile


logsFolder = "/var/log/SysCheckLogs/" # Location of file logs
newestFile = chooseNewestFile(logsFolder) # Select the most recent log file
filename = logsFolder + newestFile # Combine the filepath and name into one name
filesize = os.stat(filename) # Take the size of the filename
filesize = filesize.st_size # Place the size into a human readable format

try:
    with open(filename, 'rb') as f:
        # Create a hash out of the file
        hash = hashlib.md5(f.read()).hexdigest()
        # Display the hash information
        print(f'File hash is: {hash}')
except:
    # Print error if file was note found and exit program
    print(f"Error: {filename} file cannot be opened!")
    print("Quitting code...")
    exit(0)

# Create a socket for network communication
client_socket = socket.socket()
# Connect to the server using the IP address and port defined earlier
client_socket.connect((server_ip, server_port))
# Display a confirmation if the connection was successful. The program terminates and ends if there was an issue.
print('Connected to server.')

# Send a message with the filename, EOF, hash, and filesize. Separate information with the separator
msg = filename+sep+EOF+sep+hash+sep+str(filesize)

# Create a progress bar to measure file sending progress
progress = tqdm.tqdm(range(filesize), f'Sending file {filename}', unit='B', unit_scale=True, unit_divisor=1024)

# Encode the message
client_socket.sendall(msg.encode())
# Decode the reply message from the server after it recieves the message
reply = client_socket.recv(buffer_size).decode()

if reply == 'OK':
    # If there were no problems, send the file.
    # Iterate through the file's data in binary.
    with open(filename, 'rb') as f:
        while True:
            data = f.read(buffer_size)
            if not data:
                # If all data was sent, close the progress bar, wait for a second, and then, send the EOF character.
                progress.close()
                time.sleep(1)
                client_socket.sendall(EOF.encode())
                break
            else:
                # Send data and update progress bar
                client_socket.sendall(data)
                progress.update(len(data))
else:
    # Print error if server's reply was not "OK"
    print('Handshake process failed.')

# Display this message if file sending was successful. Otherwise, the program will print an error.
print('File sent successfully. Awaiting confirmation.')

# Recieve a reply from the server after the file was sent
reply = client_socket.recv(buffer_size).decode()

if reply == 'SUCCESS':
    # Print confirmation if transfer was successful
    print('Transfer complete.')
elif reply == 'ERROR_CHECKSUM':
    # Print an error if an error occurred while comparing hashes.
    print('Checksum error. File corrupted during transfer.')
else:
    # Print an error if the message was something else.
    print(f'Unkown message recieved: {reply}')

client_socket.close() # Close the connection
