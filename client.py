"""
Name: Server.py
Authors: Roman Kapitoulski, Eric Russon, Maryam Bunama
Version: 2.0
Date: July 30, 2023
Description: This script takes the JSON file generated by SysAdminTask.py and sends it to the Server.py software on
the server machine. It performs acknowledgments and error-checking throughout the process.
"""

import socket, hashlib, time, tqdm, os

server_ip = '127.0.0.1' # Change this to the server's IP address. 
server_port = 5000 # The port the script will communicate over
buffer_size = 1024 # The size of the packet
EOF = ':EOF:' # The "end of file" character
sep = '}}' # The data separator

def splitFile(fileName):
    # Split filename for relevant information
    fileType, fileDate, fileEnd = fileName.split("_")
    year, month, day = fileDate.split("-")
    fileTime, fileType = fileEnd.split(".")
    hour, minutes, seconds = fileTime.split("-")
    # Append the information to a datetime list
    dateTime = []
    dateTime.append(year)
    dateTime.append(month)
    dateTime.append(day)
    dateTime.append(hour)
    dateTime.append(minutes)
    dateTime.append(seconds)
    return dateTime

def chooseNewestFile(folder):
    # Get list of filenames using os.listdir()
    fileList = os.listdir(folder)

    ### Find the latest file
    # Assign the first file as the newest
    newestFile = fileList[0]
    newestFileDateTime = splitFile(newestFile)

    # Loop through fileList
    for fileName in fileList:
        fileDateTime = splitFile(fileName)
        # Compare current file to newest file
        for i in range(len(fileDateTime)):
            # As you're comparing sections of date/time, if value is greater, then file is newer
            if fileDateTime[i] > newestFileDateTime[i]:
                newestFile = fileName
                break

    return newestFile

logsFolder = "/var/log/SysCheckLogs/" # Location of file logs
newestFile = chooseNewestFile(logsFolder) # Select the most recent log file

filename = logsFolder + newestFile # Combine the filepath and name into one name
filesize = os.stat(filename) # Take the size of the filename 
filesize = filesize.st_size # Place the size into a human readable format

try:
    with open(filename, 'rb') as f:
        # Create a hash out of the file
        hash = hashlib.md5(f.read()).hexdigest() 
        # Display the hash information
        print(f'File hash is: {hash}') 
except:
    # Print error if file was note found and exit program
    print(f"Error: {filename} file cannot be opened!") 
    print("Quitting code...")
    exit(0)

# Create a socket for network communication
client_socket = socket.socket() 
# Connect to the server using the IP address and port defined earlier
client_socket.connect((server_ip, server_port)) 
# Display a confirmation if the connection was successful. The program terminates and ends if there was an issue.
print('Connected to server.') 

# Send a message with the filename, EOF, hash, and filesize. Separate information with the separator
msg = filename+sep+EOF+sep+hash+sep+str(filesize) 

# Create a progress bar to measure file sending progress
progress = tqdm.tqdm(range(filesize), f'Sending file {filename}', unit='B', unit_scale=True, unit_divisor=1024) 

# Encode the message
client_socket.sendall(msg.encode()) 
# Decode the reply message from the server after it recieves the message
reply = client_socket.recv(buffer_size).decode() 

if reply == 'OK':
    # If there were no problems, send the file.
    # Iterate through the file's data in binary.
    with open(filename, 'rb') as f:
        while True:
            data = f.read(buffer_size)
            if not data:
                # If all data was sent, close the progress bar, wait for a second, and then, send the EOF character.
                progress.close()
                time.sleep(1)
                client_socket.sendall(EOF.encode())
                break
            else:
                # Send data and update progress bar
                client_socket.sendall(data)
                progress.update(len(data))
else:
    # Print error if server's reply was not "OK"
    print('Handshake process failed.') 

# Display this message if file sending was successful. Otherwise, the program will print an error.
print('File sent successfully. Awaiting confirmation.') 

# Recieve a reply from the server after the file was sent
reply = client_socket.recv(buffer_size).decode() 

if reply == 'SUCCESS':
    # Print confirmation if transfer was successful
    print('Transfer complete.') 
elif reply == 'ERROR_CHECKSUM':
    # Print an error if an error occurred while comparing hashes.
    print('Checksum error. File corrupted during transfer.') 
else:
    # Print an error if the message was something else.
    print(f'Unkown message recieved: {reply}')

client_socket.close() # Close the connection
